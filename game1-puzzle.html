<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>拼圖遊戲</title>
<style>
  body { text-align: center; font-family: sans-serif; }
  #puzzle-container { 
    width: 306px; height: 306px; margin: 20px auto; 
    display: grid; grid-template-columns: repeat(3, 100px); 
    grid-template-rows: repeat(3, 100px); gap: 2px;
    background-color: black;
    position: relative;
  }
  .slot { border: 1px solid white; width: 100px; height: 100px; }
  .piece { width: 100px; height: 100px; background-size: 300px 300px; 
           position: absolute; cursor: grab; border: 2px solid red; }
  #full-image { width: 300px; height: 300px; margin: 0 auto; }
  #question { margin-top: 20px; display: none; }
  #question button { margin: 5px; }
  #startBtn { margin: 20px; }
</style>
</head>
<body>

<h2>拼圖遊戲</h2>
<div id="full-image-container">
  <img id="full-image" src="img/puzzle.jpg" alt="完整拼圖">
  <p id="countdown">5</p>
</div>

<button id="startBtn">開始遊戲</button>

<div id="puzzle-container"></div>

<div id="question">
  <h3>問答題：這是範例問題？</h3>
  <button data-answer="0">選項 A</button>
  <button data-answer="1">選項 B</button>
  <button data-answer="2">選項 C</button>
  <button data-answer="3">選項 D</button>
</div>

<script>
const startBtn = document.getElementById('startBtn');
const container = document.getElementById('puzzle-container');
const fullImageContainer = document.getElementById('full-image-container');
const fullImage = document.getElementById('full-image');
const countdownEl = document.getElementById('countdown');
const questionDiv = document.getElementById('question');

let pieces = [];
let correctCount = 0;
const gridSize = 3; // 3x3

function shuffleArray(array) {
  for (let i = array.length -1; i>0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function startGame() {
  startBtn.style.display = 'none';
  fullImageContainer.style.display = 'block';
  let countdown = 5;
  countdownEl.textContent = countdown;
  const timer = setInterval(()=>{
    countdown--;
    countdownEl.textContent = countdown;
    if(countdown <=0){
      clearInterval(timer);
      fullImageContainer.style.display = 'none';
      initPuzzle();
    }
  },1000);
}

function initPuzzle(){
  container.innerHTML = '';
  pieces = [];
  correctCount = 0;

  // 建立 3x3 空格
  const slots = [];
  for(let r=0;r<gridSize;r++){
    for(let c=0;c<gridSize;c++){
      const slot = document.createElement('div');
      slot.className='slot';
      slot.dataset.row=r;
      slot.dataset.col=c;
      container.appendChild(slot);
      slots.push(slot);
    }
  }

  // 建立拼圖塊
  for(let i=0;i<gridSize*gridSize;i++){
    const piece = document.createElement('div');
    piece.className='piece';
    piece.style.backgroundImage=`url(${fullImage.src})`;
    const row = Math.floor(i/gridSize);
    const col = i%gridSize;
    piece.dataset.row = row;
    piece.dataset.col = col;
    piece.style.backgroundPosition = `${-col*100}px ${-row*100}px`;
    // 隨機放置在 container 外
    piece.style.left = `${Math.random()*300}px`;
    piece.style.top = `${320 + Math.random()*200}px`;
    piece.dataset.locked = 'false';
    piece.style.zIndex = 100;
    addDragEvents(piece);
    container.appendChild(piece);
    pieces.push(piece);
  }
}

function addDragEvents(piece){
  let offsetX, offsetY;
  function dragStart(e){
    e.preventDefault();
    if(piece.dataset.locked==='true') return;
    piece.style.zIndex=200; // 拖曳時置頂
    const rect = piece.getBoundingClientRect();
    const parentRect = container.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    offsetX = clientX - rect.left;
    offsetY = clientY - rect.top;
    document.addEventListener('mousemove', dragging);
    document.addEventListener('mouseup', dragEnd);
    document.addEventListener('touchmove', dragging);
    document.addEventListener('touchend', dragEnd);
  }

  function dragging(e){
    e.preventDefault();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const parentRect = container.getBoundingClientRect();
    let x = clientX - parentRect.left - offsetX;
    let y = clientY - parentRect.top - offsetY;
    piece.style.left = `${x}px`;
    piece.style.top = `${y}px`;
  }

  function dragEnd(e){
    document.removeEventListener('mousemove', dragging);
    document.removeEventListener('mouseup', dragEnd);
    document.removeEventListener('touchmove', dragging);
    document.removeEventListener('touchend', dragEnd);
    checkPosition(piece);
  }

  piece.addEventListener('mousedown', dragStart);
  piece.addEventListener('touchstart', dragStart, {passive:false});
}

function checkPosition(piece){
  const row = parseInt(piece.dataset.row);
  const col = parseInt(piece.dataset.col);
  const slot = document.querySelector(`.slot[data-row='${row}'][data-col='${col}']`);
  const rectPiece = piece.getBoundingClientRect();
  const rectSlot = slot.getBoundingClientRect();
  const tolerance = 30;
  if(Math.abs(rectPiece.left - rectSlot.left)<tolerance && Math.abs(rectPiece.top - rectSlot.top)<tolerance){
    // 拼對位置
    piece.style.left = `${slot.offsetLeft}px`;
    piece.style.top = `${slot.offsetTop}px`;
    piece.dataset.locked='true';
    piece.style.border='none';
    piece.style.zIndex=50; // 下層
    correctCount++;
    if(correctCount === gridSize*gridSize){
      showQuestion();
    }
  }
}

function showQuestion(){
  questionDiv.style.display='block';
}

questionDiv.querySelectorAll('button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const answer = parseInt(btn.dataset.answer);
    if(answer===1){ // 假設正確是 1
      alert('恭喜通關！');
      questionDiv.style.display='none';
      startBtn.style.display='inline-block';
      container.innerHTML='';
    }else{
      alert('答錯，再試一次！');
    }
  });
});

startBtn.addEventListener('click', startGame);
</script>
</body>
</html>
